---
title: 寒假撸算法之（二）—— 并查集 & 前缀树
date: 2020-03-05 16:49:28
tags: [并查集,前缀树]
categories: 数据结构和算法
---



## 一、并查集

### 简介

并查集，顾名思义，是主要提供两个操作：“并” ，”查“的集合，函数功能如下：

Union(A,B) ：将 A 和 B 所在的集合合并。将 size 小的合并到 size 大的集合中。

isSameSet(A,B) : 返回A 和 B 所在的集合是否是同一个集合。



<!-- more -->

在并查集中，每个元素节点有一个 value 和 P 指针，P 指向上一级节点。

**代表点**：以代表点来代表该集合。例如用链表的head来代表该链表的意思。



### Union演示

1. 初始状态时，各个节点的 P 指向自身。当发生节点合并时，如1 和 2 合并，则 1 的 P 指针指向2 。如下图：

![tu1](/images/tu1.JPG)

<center>图1 初始状态</center>

2. 当 1 和 2 合并，12 和 3 合并时，如下：

![tu2](/images/tu2.JPG)

<center>图2 1和2合并</center>

3. 12 和 3 合并，如下：

![tu3](/images/tu3.JPG)

<center>图3  12和3合并</center>



### isSameSet演示

发生合并后，怎样判断两个节点是否是同一个集合？

——从该节点出发，利用 P 不断向上找节点，直到 P 指向自身时，返回该节点，即为此集合的代表点。

若 A代 == B代 ，则 A 和 B在同一个集合中；不等，则不在。



### 优化——路径压缩

也叫扁平化处理。在 查询操作 isSameSet(A,B) 的过程中，A 沿途的链所有节点都打平，B 沿途的链也打平 ，再返回true / false 。【为后续的查询操作加快速度】

![tu4](/images/tu4.png)

<center>图4  扁平化处理</center>

### Code

注意：必须一开始就拿到所有数据，而不是动态的增加数据

```jav
public class Data{
	//填啥都行，为了封装数据而已 以int为例
	public int value;
}

public class UnionFindSet{
	public HashMap<Data,Data> fatherMap;  //(key,value)表示key的父节点是value
	public HashMap<Data,Integer> sizeMap; //(key,int)只有在key是此集合的代表节点时，int表示此集合的size ； 否则无意义

	public UnionFindSet(List<Data> nodes){
		fatherMap = new HashMap<Data,Data>();
		sizeMap = new HashMap<Data,Integer>();
		makeSets(nodes);
	}

	private void makeSets(List<Data> nodes){ //构建集合
		fatherMap.clear();
		sizeMap.clear();
		for(Data node : nodes){
			fatherMap.put(node,node); //指向自身
			sizeMap.put(node,1); //size = 1
		}

	}

	private Data findRepresent(Data node){ //查询node的代表点的同时，将node挂到代表点上
		Data father = fatherMap.get(node);
		if(father != node){
			father = findRepresent(father);
		}
		fatherMap.put(node,father);
		return father;
	}

	public boolean isSameSet(Data a, Data b){//返回a，b是否在同一个集合中
		return findRepresent(a) == findRepresent(b);
	}

	public void union(Data a, Data b){ // 合并a，b所在集合
		if(a == null || b == null){
			return;
		}
		Data aRepresent = findRepresent(a);
		Data bRepresent = findRepresent(b);
		if(aRepresent != bRepresent){ //a b的代表结构不同才会发生合并操作
			int aSetSize = sizeMap.get(aRepresent);
			int bSetSize = sizeMap.get(bRepresent);
			if(aSetSize <= bSetSize){ //size小的挂到大的上
				fatherMap.put(aRepresent,bRepresent);
				sizeMap.put(bRepresent,aSetSize+bSetSize);
			}else{
				fatherMap.put(bRepresent,aRepresent);
				sizeMap.put(aRepresent,aSetSize+bSetSize);
			}
		}
	}

}
```



### 时间复杂度分析

注：某大牛从1964年证明到1989年，整整25年才证明出这个结构有多牛逼。

当元素个数到 O(N) 数量级时，若**查询次数+合并次数**（因为合并中也包含着查询）达到 O(N) 及其以上，则平均单次查询/合并的复杂度是 O(1) 级别。

有点绕是吧？就是说，如果有10000个节点，我们查询或者合并的次数达到了 10000 次或者 $10000^2$ 及其以上，则平均下来再次查询/合并的代价是 O( α(N) ) 。

其中，α(N) 是个成长极其缓慢的函数。可否具体？当 N 达到  10^80 （目前人类已经探明的总原子数）时，α(N) 返回值不会超过 6 ，所以可以看作是 O(1) 的代价。

-----





## 二、前缀树

### 简介

英文：trie tree / prefix tree。前缀树是用于保存关联数组的数据结构，简单一点地说，它可以很快速的返回两个字符串是否有相同的前缀内容。更详细的定义见：[维基百科的定义](https://zh.wikipedia.org/wiki/Trie)

如果您没看懂，看一下下面的图就知道什么意思了。

![前缀树简介](/images/tu5.png)	

<center>图5 前缀树简介</center>



### 封装节点：

pass：表示有多少个节点经过本节点（共享本节点的字符串数量）

end： 表示有多少字符以这个节点结尾（最下面的节点 end=1，越往上end越大）

nexts[] :用于保存这个节点。



### 有什么用？

也许你还是不知道这个数据结构可以干嘛。那么思考一下这个问题：**查询 ”helo“ 是否在集合中出现过？**  



常规的思路不外乎三种：1.遍历整个集合来看；2.在保存这个集合时就用 hashmap 来进行存储。

而如果是使用**前缀树**的思路：依次看 ‘h’ , 'e' , 'l' , 'o' 这些节点有没有在树中出现过。  

![寻找helo](/images/tu6.png)

<center>图6 寻找helo</center>

如果该树没有保存 ‘helo’，那么到 'hel'时，算法就会结束；保存了后，则会正常的找到。而这个过程中的时间复杂度，仅仅和***要查找的单词长度***有关系。





### Code

为了实现得简单一些，约定总共就26个小写字母，所以可以用数组来写了。(如果是更复杂的情况，可以替换为 HashMap )。

代码中的index作用：用下一个节点对应的ASCII码来的位置置为 1 ，表示该字母被保存。比如：下一个节点指向 'a' ，则 nexts[0] = 下一个节点 ; 指向 'z' ，则 nexts[25] = 下一个节点。



具体代码如下，已经加了注释，不懂的欢迎留言：

```java
public class TrieNode{  //前缀树中封装的单个节点
	public int pass; //表示有多少个节点经过本节点（共享本节点的字符串数量）
	public int end; // 表示有多少字符以这个节点结尾
	public TrieNode[] nexts; 

	public TrieNode(){
		pass = 0;
		end = 0;
		nexts = new TrieNode[26]; //默认只有26个字母。若是中文改为Map
	}	
}


public class Trie{  //前缀树
	private TrieNode root;

	public Trie(){
		root = new TrieNode();
	}

	public void insert(String word){ //往树中插入 word
		if(word == null){
			return;
		}
		char[] chs = word.toCharArray();
		TrieNode node = root;
		int index = 0;
		for(int i = 0; i < chs.length; i++){
			index = chs[i] -'a';
			if(node.nexts[index] == null){
				node.nexts[index] = new TrieNode();
			}
			node = node.nexts[index];
			node.pass++;//沿途pass++，说明本节点被共享的次数增加了
		}
		node.end++;	//以本节点结束的字符串++	
	}

	public void delete(String word){ //沿途node.pass-- 可以更好
		if(search(word) != 0){ //要删除的元素存在
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0 ;
			for(int i = 0; i < chs.length; i++){
				index = chs[i] - 'a';
				if(--node.nexts[index].pass == 0){
					node.nexts[index] = null;
					return;
				}
				node = node.nexts[index];
			}
		}
		node.end--;
	}

	public int search(String word){ //查询word是否出现过
		if(word == null){
			return 0;
		}
		char[] chs = word.toCharArray();
		TrieNode node = root;//从根开始找
		int index = 0;
		for(int i = 0; i < chs.length; i++){
			index = chs[i] - 'a';
			if(node.nexts[index] = null){	
				return;
			}
			node = node.nexts[index];
		}
		return node.end;
	}

	public int prefixNumber(String pre){ //返回以pre为前缀的字符串数
		if(pre == null){
			return 0;
		}
		char[] chs = pre.toCharArray();
		TrieNode node = root;//从根开始找
		int index = 0;
		for(int i = 0; i < chs.length; i++){
			index = chs[i] - 'a';
			if(node.nexts[index] = null){	
				return 0;
			}
			node = node.nexts[index];
		}
		return node.pass; 
	}

}
```



### 时间复杂度

插入，删除，查询都只需要目标字符串的长度时间，即 T( N ) = O( N )



### 应用

图、字符串中的很多操作都可以用到前缀树，后续的文章中会一一讲解，敬请期待。