---
title: 荷兰国旗问题
date: 2020-03-05 23:02:17
tags: [Easy,Java,List]
categories: 每日刷题
---

【题目大意】给定一个单向链表，将单向链表按某个值划分成左边小、中间相等、右边大的形式。

<!-- more -->

## 题目

给定一个单向链表的头节点 head ,节点的值类型是整型，再给定一个整数 pivot 。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。除这个要求外，对调整后的节点顺序没有更多的要求。

例如: 链表9 ->0- ->4 ->5->1，pivot = 3。 调整后链表可以是1->0->4->9->5， 也可以是0->1->9->5->4。总之，满足左部分都是小于3的节点，中间部分都是等于3的节点(本例中这个部分为空)，右部分都是大于3的节点即可。对某部分内部的节点顺序不做要求。



## 法一：借鉴快排Partition的思路

### 思路

回想一下快速排序中的 Partition ，也是把数组的某个部分划分成 < = > 某个数的功能。那么我们也可以借鉴其思路，将链表转换为数组后，用 Partition 来进行操作。



### Code

```java
// Node 的定义省略，仅仅有value和next两个属性

public Node ListPartion(Node head,int pivot){
    if(head == null){
        return head;
    }
    Node cur = head;
    int i = 0;
    while(cur != null){ //计算数组需要多大容量
        i++;
        cur = cur.next;
    }
    Node [] nodeArr = new Node[i];
    i = 0;
    cur = head;
    for(i = 0 ; i < nodeArr.length ; i++){ //将node保存在数组中
        nodeArr[i] = cur;
        cur = cur.next;
    }
    arrPartion(nodeArr,pivot);
    for(i=1 ; i < nodeArr.length ; i++){
        nodeArr[i-1].next = nodeArr[i]; //重新确定next的指向
    }
    NodeArr[i-1].next = null;//最后一个节点需要特别处理一下
    return nodeArr[0]; //返回第一个节点
}
```

时间复杂度：需要遍历整个 List ，所以 T(n) = O(n) 。

空间复杂度：由于需要保存 List 的所有节点，所以 S(n) = O(n) 。





## 法二：三个变量解决战斗

### 思路

用三个变量 less，equal，more 保存 < = > 目标值的第一个位置；再遍历一次链表，让符合条件的节点分别挂在上述三个节点上；最后将三个链表连起来返回头节点。

注意细节：

{% asset_img sanbianliang.png 三变量法的细节 %}

<center>图1 三变量法的细节</center>



### Code

```java
public Node ListPartition2(Node head,int pivot){
    Node sH = null; Node sT = null; //small区的head和tail
    Node eH = null; Node eT = null; 
    Node bH = null; Node bT = null; 
    Node next = null ; //save next node
    
    //每个node都被分到三个List中
    while(head!=null){
        next = head.next; 
        head.next = null;
        
        if(head.value < pivot){  //1.说明存在第一条链
            if(sH == null){//第一个节点不存在时
                sH = head;
                sT = head;
            }else{//往后只需要把当前节点串到sT后面即可
                sT.next = head；
                sT = head;//sT指向当前节点后后移
            }
        }
        
        else if(head.value == pivot){ //2.不存在第一条，存在第二条链
            if(eH == null){ //同上
                eH = head;
                eT = head;
            }else{
                eH.next = head;
                eT = head;
            }
        }
        
        else{
             if(bH == null){ //同上
                bH = head;
                bT = head;
            }else{
                bH.next = head;
                bT = head;
            }
        }
        
        //上述的三个if其实仅仅是对一个节点的判断
        head = next;//移动当前节点
    }
    
    //将small、equal连起来(如果存在small链)
    if(sT != null){
        sT.next = eH;
        eT = eT==null ? sT : eT;   //如果eT为空，equal链不存在，和sT合在一起；否则保留
    }
    
    //All connect
    if(eT != null)
        eT.next = bH;
    
    return sH != null ? sH : eH != null ? eH : bH;// HHH皮一下，意思就是返回sH,eH,bH中最前存在的一个
}
```

时间复杂度：需要遍历整个 List ，所以 T(n) = O(n) 。

空间复杂度：由于只需要保存 3 个节点，所以 S(n) = O(1) 。



法二的代码比法一的多一些，但其实都是重复了三次的代码，主体思路就是：遍历 List 时，比较大小关系，让当前节点串到对应的链表，最后连接三条链表时注意下细节的处理（链表是否为空）。把握了主体思路，本道题迎刃而解。