---
title: 字符串操作中不得不提的朋友——正则表达式
date: 2020-02-29 23:06:42
categories: Java
tags: String
---

## 一、简述

正则表达式，Regular Expression ，又称规则表达式，简写为reg exp。学习String 类的时候，有很多方法中用到了regex。详见[维基百科“正则表达式词条” ](https://zh.wikipedia.org/wiki/正则表达式)。

正则表达式是一种带有规律 、格式的表达式。通常用来匹配格式、替换、检索。



<!-- more -->

### 作用

在很多开发场景都会看到正则表达式的影子，一言以蔽之，其作用无非一下三种：

***1.格式检验；2.拆分替换；3.检索字串*** 。

就Java来说，前两个作用通过String类就可以完成了，如：

```java
String str = new String();
str.matches(regex);
str.split(regex)
str.replaceFirst(regex, replacement);
```

第三个作用需要依赖Pattern模式 ，Matcher匹配器进行操作，将在下文进行详细叙述。



### 正则表达式的来由

“知其然，知其所以然。”下面简单普及一下正则的由来。

最初的正则表达式出现于[理论计算机科学](https://zh.wikipedia.org/wiki/理論計算機科學)的[自动控制](https://zh.wikipedia.org/wiki/自动控制)理论和[形式化语言](https://zh.wikipedia.org/wiki/形式化语言)理论中。在这些领域中有对计算（自动控制）的模型和对[形式化语言](https://zh.wikipedia.org/wiki/形式化语言)描述与分类的研究。

正则表达式鼻祖——1940年，[沃伦·麦卡洛克](https://zh.wikipedia.org/wiki/沃伦·麦卡洛克)与[Walter Pitts](https://zh.wikipedia.org/w/index.php?title=Walter_Pitts&action=edit&redlink=1)将[神经系统](https://zh.wikipedia.org/wiki/神经系统)中的神经元描述成小而简单的自动控制元。

1950年代，数学家[斯蒂芬·科尔·克莱尼](https://zh.wikipedia.org/wiki/斯蒂芬·科尔·克莱尼)利用称之为“正则集合”的数学符号来描述此模型。[肯·汤普逊](https://zh.wikipedia.org/wiki/肯·汤普逊)将此符号系统引入编辑器[QED](https://zh.wikipedia.org/w/index.php?title=QED_(文字編輯器)&action=edit&redlink=1)，随后是[Unix](https://zh.wikipedia.org/wiki/Unix)上的编辑器[ed](https://zh.wikipedia.org/w/index.php?title=Ed_(文字編輯器)&action=edit&redlink=1)，并最终引入[grep](https://zh.wikipedia.org/wiki/Grep)。自此以后，正则表达式被广泛地应用于各种Unix或[类Unix](https://zh.wikipedia.org/wiki/类Unix)系统的工具中。正则表达式的POSIX规范，分为基本型正则表达式（Basic Regular Expression，BRE）和扩展型正则表达式（Extended Regular Express，ERE）两大流派。在兼容POSIX的UNIX系统上，grep和egrep之类的工具都遵循POSIX规范，一些数据库系统中的正则表达式也符合POSIX规范。grep、vi、sed都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义。egrep、awk则属于ERE，元字符不用转译



或许你没什么兴趣看完上述的东西，但笔者想说：理解原理，也要适时的理解其来龙去脉，用思想层面提升维度。很多知识都是跨学科的，比如SSM的创始人们不少都不是程序员出身。



真正掌握面向对象的编程---> 需要从思维层次去思考    not just code





## 二、正则表达式的具体使用

笔者不才，记不住太多的正则用法，下文仅仅是从自身的体验出发，列出了最最常用的几个用法。

> 窃以为，正则归根到底是一个工具而不是用来炫技的，更多用法需要时直接Google即可，记住最基础的才是王道。



### 基本的表达式：

首先说明，[ ]不是闭区间，而是**表达式**的开始和结束

可以记一下这几个符号：-    ^     &    |    ，分别表示：    范围  ， 非  ， 与   或   。

所有的逻辑都可以从上述几个符号组合产生



[abc] : 表示输入的是abc中的一个

[^abc] : 表示输入的不是a、b或者c中的其中一个

[a-z] : 表示a-z字母范围（大写就不行了）   因为底层是Unicode

[A-Za-z] : 表示是**字母**

[a-z&&[ ^ bc]] : 表示a-z且不是b或者c



### 简化版

随着表达式越来越长，写起来必然很麻烦，所以有些开发中将常用的**范围**做了一些简化

.  : 代表任意一个子符

数字：\d ，等价于[0-9]，代表任一个数字   digit

非数字：\D  ，等价于[ ^0-9]

留白：空格\s  (space)    回车\r  换行\n

非留白：\S

单词：\w   [0-9A-Za-z]    word单词的意思

非单词：\W



> 再次强调，上述用法都是用来做匹配的——且仅仅匹配一个字符。



### 匹配多个字符

如果需要匹配的字符不是一个而是多个，则需要用到次数来进行匹配。

带上了次数的正则表达式的总公式：   **[表达式]{次数} **    。

下面讲解{}中次数的写法：



- ? ：0-1次  （可理解为 “出现过？？”）
- \* ：0-n次 （出没出现过都行）
- \+ ：1-n次 
- {n} ：固定n次
- {n,}：至少n次
- {n,m}：n-m次

```java
//正则表达式 就是一些符号  不用死记硬背
//需要时查API(Application Programming Interface)即可 

public static void main(String[] args){
    Scanner input = new Scanner(System.in);
    System.out.println("请您输入一个字符串");
    String value = input.nextLine(); //a
    
    //用value判断是否满足某种规则（正则）
    boolean result = value.matches("[abcd]");// [abcd] ：含有其中一个，返回true
    System.out.println(result);
}
```



### 检索

```java
 //有一个字符串message（可以从网络、数据库JDBC、IO中读取）
 //搜索message中有多少个符合某种编码格式的字符串
public static void main(String[] args){
    String message = "150000msq150001abcd150002";
    
    //要做检索工作，String不行 需要Pattern类
    Pattern pattern = Pattern.compile("[0-9]{6}");//此方法的参数是正则表达式
    
    //需要一个匹配器来执行扫描
    Matcher matcher = pattern.matcher(message);//此方法按照pattern规则扫描message，返回一个匹配器
    
    while(matcher.find()){
        String v = matcher.group();
        System.out.println(v);
    }
    
}
```



看到这里，笔者想跟小主透露件小知识，String的matches，split，replace等方法，底层所调用的方法也是用到了Pattern和Matcher。不信？请看源码：

```java
	/* @since 1.4
     * @spec JSR-51
     * matches的源代码
     */
    public boolean matches(String regex) {
        return Pattern.matches(regex, this);
    }
    

    /* split的源代码
     */
    public String[] split(String regex, int limit) {
        /* fastpath if the regex is a
         (1)one-char String and this character is not one of the
            RegEx's meta characters ".$|()[{^?*+\\", or
         (2)two-char String and the first char is the backslash and
            the second is not the ascii digit or ascii letter.
         */
        char ch = 0;
        if (((regex.value.length == 1 &&
             ".$|()[{^?*+\\".indexOf(ch = regex.charAt(0)) == -1) ||
             (regex.length() == 2 &&
              regex.charAt(0) == '\\' &&
              (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&
              ((ch-'a')|('z'-ch)) < 0 &&
              ((ch-'A')|('Z'-ch)) < 0)) &&
            (ch < Character.MIN_HIGH_SURROGATE ||
             ch > Character.MAX_LOW_SURROGATE))
        {
            int off = 0;
            int next = 0;
            boolean limited = limit > 0;
            ArrayList<String> list = new ArrayList<>();
            while ((next = indexOf(ch, off)) != -1) {
                if (!limited || list.size() < limit - 1) {
                    list.add(substring(off, next));
                    off = next + 1;
                } else {    // last one
                    //assert (list.size() == limit - 1);
                    list.add(substring(off, value.length));
                    off = value.length;
                    break;
                }
            }
            // If no match was found, return this
            if (off == 0)
                return new String[]{this};

            // Add remaining segment
            if (!limited || list.size() < limit)
                list.add(substring(off, value.length));

            // Construct result
            int resultSize = list.size();
            if (limit == 0) {
                while (resultSize > 0 && list.get(resultSize - 1).length() == 0) {
                    resultSize--;
                }
            }
            String[] result = new String[resultSize];
            return list.subList(0, resultSize).toArray(result);
        }
        return Pattern.compile(regex).split(this, limit);
    }

	
	 /*
     * @since 1.4
     * @spec JSR-51
     * replaceAll的源代码
     */
    public String replaceAll(String regex, String replacement) {
        return Pattern.compile(regex).matcher(this).replaceAll(replacement);
    }
```



## 三、写在最后

正则表达式是开发过程中涉及到字符串相关操作的一个有力工具，它不是某种语言所独有的特性，主流的开发语言中都有相关正则表达式的用法。

笔者写这篇文章，仅仅是为了给小白们一点参考，或许“从未遇见，一直听说”，至少看了这篇文后，有了最基本的了解。还望大牛们不吝赐教。

