---
title: 百度二面面经
date: 2020-04-04 21:53:28
tags: [百度,面经]
categories: 面经
---

继上次的文章后很久没更新了，一方面确实懒，一方面感觉来来去去都是那些问题。不过出于完整性，还是决定写完。目前笔者也幸运拿到了百度的 offer ，下面回顾一下二面的面试题吧~

<!-- more -->

### 1、https 和 http 区别。

- https 协议需要申请 CA 证书，一般免费证书很少，需要交费。
- http 是超文本传输协议，信息是明文传输；https 则是具有安全性的 ssl 加密传输协议。
- http 用 80 端口，https 用 443 端口。
- http 连接很简单，是无状态的协议；https 是由 SSL + http 协议构成的具有身份认证、加密传输功能的网络协议，比 http 安全得多。

上面四点是必须会的，如果希望答得出彩一点，可以加入以下观点进行回答：

https 的安全基础是 ssl ，ssl 是建立在 TCP 之上的协议。建立连接时需要三次握手，断开时需要四次挥手，相应地，速度也比 http 慢；ssl 层用到了数字签名来保证数据的完整性，用了对称加密来传输内容，非对称加密来加密密钥。（见前一篇 Blog ）



---

### 2、什么是死锁？死锁的必要条件？产生死锁的原因？

​	1）死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种**互相等待**的现象，若无**外力**作用，它们都将无法推进下去。



​	2）死锁的必要条件：以下四个条件只要有一个被破坏，就不会发生死锁。

- **互斥条件**：一个资源每次只能被一个进程使用。<u>【这一条无法被禁止，互斥是资源的固有属性】</u>
- **请求与保持条件**：一个进程因为请求资源而阻塞时，已经获得的资源保持不放。
- **不剥夺条件**：进程已经获得的资源，在未使用完之前，不能强行剥夺。
- **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

 请求与保持、不剥夺看着有点相似，我的理解是：前者是运行到中途停下来，去请求别的资源了，则已经有的不能放弃；后者是正常运行中的进程，此时系统不能去抢夺人家的资源。



​	3）产生死锁的原因：

- **系统资源不足**
- **资源分配不当**
- **进程运行推进顺序不合适**



---

### 3、数字证书的作用

数字证书是由证书认证机构签名的包含公开密钥拥有者信息、公开密钥、签发者信息、有效期以及一些扩展信息的数字文件。

从证书的用途来看，数字证书可分**为签名证书**和**加密证书**。签名证书主要用于对用户信息进行签名，以保证信息完整性和行为的不可抵赖；加密证书主要用于对用户传送信息进行加密，以保证信息的机密性



---

### 4、多进程和多线程的区别

|     对比维度     |                      多进程                       |                多线程                | 适合线程否？ |
| :--------------: | :-----------------------------------------------: | :----------------------------------: | :----------: |
|  数据共享、同步  | 数据共享复杂，需要用 IPC ；数据是分开的，同步简单 | 共享进程数据，同步简单，但是同步负责 |   各有优势   |
|    内存、CPU     |             占用内存多，CPU 利用率低              |       占用内存低，CPU 利用率高       |      √       |
| 创建、销毁、切换 |                   复杂，速度慢                    |             简单，速度快             |      √       |
|    编程、调试    |                编程简单，调试简单                 |        编程复杂、调试复杂复杂        |              |
|      可靠性      |                进程间不会相互影响                 |    一个线程挂了会导致整个进程挂了    |              |
|      分布式      |  适用于多核、多机分布式；扩展到多台机器比较简单   |        适应于单机子多核分布式        |              |



---

### 5、什么是Hash冲突？怎样解决？

Hash 冲突：一个 key 经过 hash 函数计算后的结果作为地址去存放当前的 key - value 对，但是发现算出来的地址上已经存放了别的键值对了。这就是 Hash 冲突。



解决方法：

- 开放地址法
  - 线性探测法：最简单的处理处理冲突的方法。插入元素时，如果发生冲突，就从该位置往后遍历 hash 表直到找到下一个空槽，将该元素放入槽中。查找对象时同理，算出位置后也要遍历直到匹配才返回 k-v。
  - 线性补偿探测法：将线性探测的步长从 1 改成 Q ，即 hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。
  - 伪随机探测：将步长从常数改为随机数。即：hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。
- 拉链法：在发生冲突的地方生成链表。【不再赘述，参考 hashmap 的解决方法】
- 再散列：发生冲突时，使用第二个、第三个、.... hash 函数计算地址，直到无冲突
- 建立一个公共溢出区：假设 hash 函数的值域为 [0,m-1]，则设置 HashTable[0...m-1] 为基本表，另外设置向量 OverTable[0...v] 保存冲突的值。

---

### 6、session 和 cookie 的区别

见之前一篇 Blog

---

### 7、TCP 和 UDP 的区别

#### - TCP

- 一种面向连接的、可靠的、基于字节流的传输层通信协议。在建立连接时需要三次握手，断开连接时需要四次挥手才能完全断开。为数据的可靠传输打下了基础。

- 仅支持单播传输：每条 TCP 传输连接只能有两个端点，因此只能进行点对点的数据传输。
- 面向字节流：TCP 在不保留报文边界的情况下以字节流方式进行传输。
- 可靠传输：给每一个包一个序号，保证传送到接收端实体的包按序接收。接收端实体对已经成功收到的字节发回相应的确认( ACK )；如果在 RTT 内未收到确认，则会进行重传。
- 提供拥塞控制：当网络出现拥塞的时候， TCP 能够减小向网络注入数据的速率和数量，缓解拥塞。
- 全双工通信：通信的双方在任何时候都能发送数据。
- 头部最小 20 字节，最大 60 字节：传输开销较大。



#### - UDP

- **面向无连接**：UDP 是一种无连接的协议，想发送数据就可以开始发送，只是数据报文的搬运工，不会对数据报文进行任何的拆分和拼接工作。【在**发送端**：UDP 只会给报文增加一个 UDP 头标识，就向下传递给网络层了；在**接收端**：网络层将数据传递给传输层时，UDP 仅仅去除 IP 报文头就传递给应用层】
- **有单播、多播、广播**的功能
- **面向报文**：UDP 不拆分、合并报文，因此应用程序必须选择合适大小的报文
- **不可靠性**：无连接，不关心对方是否收到消息，会一直以恒定的速度发送数据（即使网络不好）。
- 头部开销小，传输报文很**高效**：总共八字节



---

8、二分查找代码。如果有重复值怎样找到第一个元素

此题灰常 easy ，略了。

---

### 参考资料

- [多进程和多线程的区别及适用场景](https://blog.csdn.net/RUN32875094/article/details/79515384)
- [解决Hash冲突的方法](https://blog.csdn.net/u012104435/article/details/47951357)