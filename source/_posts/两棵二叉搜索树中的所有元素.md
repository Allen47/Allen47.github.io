---
title: 两棵二叉搜索树中的所有元素
date: 2020-03-06 23:17:28
tags: [Java,medium]
categories: 每日刷题
---

## [【LeetCode】1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)

### 题目

给你 root1 和 root2 这两棵二叉搜索树。

请你返回一个列表，其中包含 两棵树 中的所有整数并按升序排序。.

 <!-- more -->

示例 1：

![image1](/images/2-1.png)

输入：root1 = [2,1,4], root2 = [1,0,3]
输出：[0,1,1,2,3,4]

示例 2：

输入：root1 = [0,-10,10], root2 = [5,1,7,0,2]
输出：[-10,0,0,1,2,5,7,10]



示例 3：

输入：root1 = [], root2 = [5,1,7,0,2]
输出：[0,1,2,5,7]
示例 4：

输入：root1 = [0,-10,10], root2 = []
输出：[-10,0,10]
示例 5：

![image2](/images/2-2.png)

输入：root1 = [1,null,8], root2 = [8,1]
输出：[1,1,8,8]


提示：

每棵树最多有 5000 个节点。
每个节点的值在 [-10^5, 10^5] 之间。



---



### 思路

#### 法一：Collect and Sort

将两棵树中的元素收集到一个数组中，进行排序，可以很快解决。【此方法 Code 过于 easy ，省略略略略略】

时间复杂度：T( N ) = O( NlogN )

空间复杂度：需要存下所有的节点， S( N ) = O( N )



#### 法二：Inorder traversal + merge

由于题目中给的树是 BST ，我们可以充分利用二叉搜索树的性质：左子树 <= 根 < 右子树。分别将两棵树进行中序遍历后存到两个数组中，再对两个数组进行 merge 操作，即可得到结果。



Code:

```java
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        inorder(root1, list1);
        inorder(root2, list2);

        return merge(list1, list2);
    }
	
    private void inorder(TreeNode node, List<Integer> list) {//中序遍历存入list
        if(node == null) return;

        inorder(node.left, list);
        list.add(node.val);
        inorder(node.right, list);
    }

    private List<Integer> merge(List<Integer> list1, List<Integer> list2) {
        List<Integer> rtn = new ArrayList<>();
        int size1 = list1.size();
        int size2 = list2.size();
        int idx1 = 0, idx2 = 0;
        while(idx1 < size1 && idx2 < size2) { //merge操作
            int num1 = list1.get(idx1);
            int num2 = list2.get(idx2);
            if(num1 < num2) {
                rtn.add(num1);
                idx1++;
            } else {
                rtn.add(num2);
                idx2++;
            }
        }
        while(idx1 < size1) {
            rtn.add(list1.get(idx1++));
        }
        while(idx2 < size2) {
            rtn.add(list2.get(idx2++));
        }
        return rtn;
    }
}
```

时间复杂度：遍历两个链表 O( N ) 的复杂度，merge 操作 O( N ) 的复杂度，最终，T( N ) = O( N )

空间复杂度：需要存下所有的节点， S( N ) = O( N )





#### 法三：Merging while traversal

法二已经利用了 BST 的相关性质，将 O( NlogN ) 的复杂度下降到了 O(N) ，但是其中对两棵树的元素其实进行了两次遍历。我们能否做到一次遍历就出结果来呢？也就是，在遍历的同时进行 merge 操作，遍历结束时，答案也出来了。



解法：

1. 用两个栈来实现遍历两棵树的左子树，一边遍历一遍压栈，在未访问到右子树时，栈顶保存着当前树最小的元素（当然，未访问了右子树后栈顶元素也是最小的，只是此时还没开始处理右子树）；
2. 比较两个栈的栈顶，栈顶小的弹出元素到 ans 列表中；依次比较直到两个栈空；
3. 接着继续访问右子树，对它做相同的操作(遍历，比较栈顶)。直到整棵树被访问完，



code：

```java
class Solution {
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        List<Integer> ans = new ArrayList<Integer>();
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        Stack<TreeNode> s2 = new Stack<TreeNode>();
        Smallest(root1,s1);
        Smallest(root2,s2);

        Stack<TreeNode> s;
        while(!s1.isEmpty() || !s2.isEmpty()){
            if(!s1.isEmpty())
                 s = s1;
            else if(!s2.isEmpty())
                 s = s2;
            
            if(s1.peek().val < s2.peek().val) //这个if，仅仅是为了下面弹出元素时方便确定弹出谁的栈顶
                s = s1;
            else s = s2;

            TreeNode temp = s.pop();
            ans.add(temp.val);
            Smallest(temp.right,s); //对当前temp的右边节点进行压栈操作。 //此temp可能来自s1 or s2
        }
        return ans;
    }

    public void Smallest(TreeNode root,Stack<tre s){  //将root的最小值一直压栈
        if(root == null) return;
        s.push(root);
        Smallest(root.left,s);
    }
}
```

时间复杂度：遍历两个链表 O( N ) 的复杂度，merge 操作 O( 1 ) 的复杂度，最终，T( N ) = O( N )

空间复杂度：需要存下所有的节点， S( N ) = O( N )



法三相比法二，仅仅遍历一遍两棵树就得到了结果，虽然同是 O( N ) 的复杂度，但是速度更快噢。





